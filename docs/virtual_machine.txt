For simplicity, this is a stack machine.
However, it is a modified one.


Registers:
  pc:   program counter
  sp:   stack pointer
  fp:   frame pointer (points to the start of the stack frame)
  arg_space:  size of space allocated for arguments


Stack frame:
  fp - arg_space - 24:   old fp
  fp - arg_space - 16:   old arg_space
  fp - arg_space - 8:   return value
  fp - arg_space:       ap points to this
  fp:                   return address
  fp + 8:               local variables


Instructions:
  constant(immediate):
    {
      push(immediate);
    }

  //get_arg_space:
  //  {
  //    push(arg_space);
  //  }
  arg:
    {
      push(fp - arg_space);
    }
  argx:
    {
      push(fp - arg_space + pop());
    }
  var:
    {
      push(fp + 8);
    }
  varx:
    {
      push(fp + 8 + pop());
    }


  ld:
    {
      base = pop();
      push(mem[base]);
    }
  ldx:
    {
      base = pop();
      index = pop();
      push(mem[base + index]);
    }
  st:
    {
      base = pop();
      data = pop();
      mem[base] = data;
    }
  stx:
    {
      base = pop();
      index = pop();
      data = pop();
      mem[base + index] = data;
    }
  dispnum:
    {
      cout << pop();
    }

  getnum:
    {
      cin >> a;
      push(a);
    }


  binop(type):
    {
      a = pop();
      b = pop();

      switch (type)
      {
        case ...:
          push(a op b);
          break;
          ...
      }
    }

  beq:
    {
      a = pop();
      offset = pop();

      if (a == 0)
      {
        pc = pc + offset;
      }
    }
  bne:
    {
      a = pop();
      offset = pop();

      if (a != 0)
      {
        pc = pc + offset;
      }
    }

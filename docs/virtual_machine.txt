For simplicity, this is a stack machine.
It uses byte addressing.
The basic integer type is implemented as int64_t.


Registers:
  pc:   program counter
  sp:   stack pointer
  fp:   frame pointer (points to the start of the stack frame)
  arg_space:  size of space allocated for arguments


Stack frame:
  fp - arg_space - 24:   old fp
  fp - arg_space - 16:   old arg_space
  fp - arg_space - 8:   return value
  fp - arg_space:       ap points to this
  fp:                   return address
  fp + 8:               local variables

Encodings:
  

Instructions:
  // Implemented as 10 bytes
  constant(immediate):
    {
      push(immediate);
    }

  //get_arg_space:
  //  {
  //    push(arg_space);
  //  }
  get_retval
  arg:
    {
      push(fp - arg_space);
    }
  argx:
    {
      push(fp - arg_space + pop());
    }
  var:
    {
      push(fp + 8);
    }
  varx:
    {
      push(fp + 8 + pop());
    }


  ld(type):
    {
      base = pop();
      push((s64)*((type*)(&mem[base])));
    }
  ldx(type):
    {
      base = pop();
      index = pop();
      push((s64)*((type*)(&mem[base + index])));
    }
  st(type):
    {
      base = pop();
      data = pop();
      *((type*)(&mem[base])) = data;
    }
  stx(type):
    {
      base = pop();
      index = pop();
      data = pop();
      *((type*)(&mem[base + index])) = data;
    }

  // Display 64-bit integer
  dispnum:
    {
      cout << pop();
    }

  // Get 64-bit integer from standard input
  getnum:
    {
      cin >> a;
      push(a);
    }



  // Binary operator, such as math, logic, bitwise, and comparisons.
  binop(type):
    {
      a = pop();
      b = pop();

      switch (type)
      {
        case ...:
          push(a op b);
          break;
          ...
      }
    }


  // Branch if equal to zero
  beq:
    {
      val = pop();
      offset = pop();

      if (val == 0)
      {
        pc = pc + offset;
      }
    }

  // Branch if not equal to zero
  bne:
    {
      val = pop();
      offset = pop();

      if (val != 0)
      {
        pc = pc + offset;
      }
    }

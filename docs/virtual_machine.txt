For simplicity, this is a stack machine.
It uses byte addressing.
The basic integer type is implemented as int64_t.

However, compares and divisions and remainders can be made to act as if
both arguments are uint64_t.

Other types of integers are supported for loads and stores.


Registers:
  pc:   program counter
  sp:   stack pointer
  fp:   frame pointer (points to the start of the stack frame)


Stack frame:
  fp - arg_space - 8:   old fp
  fp - arg_space:       arguments to this specific call of the function, in
                        reverse order.
                        Example:  For a function with two arguments, the
                        first argument to the function is at (fp - 8), and
                        the second argument to the function is at (fp - 16)

  fp:                   return address
  fp + 8:               local variables of this specific call of the
                        function

Encodings:
  No arguments:         Two bytes used, representing
  constant(immediate):  10 bytes used
  binop(type):          Four bytes used
  ld(type):             Four bytes used
  ldx(type):            Four bytes used
  st(type):             Four bytes used
  stx(type):            Four bytes used

Instructions:
  // Put constant value onto the stack
  const(immediate):
    {
      push(immediate);
    }
  const_u32(immediate)
    {
      push(zero_extend_32(immediate));
    }
  const_s32(immediate)
    {
      push(sign_extend_32(immediate));
    }
  const_u16(immediate)
    {
      push(zero_extend_16(immediate));
    }
  const_s16(immediate)
    {
      push(sign_extend_16(immediate));
    }
  const_u8(immediate)
    {
      push(zero_extend_8(immediate));
    }
  const_s8(immediate)
    {
      push(sign_extend_8(immediate));
    }

  arg:
    {
      push(fp);
    }
  argx:
    {
      push(fp + pop());
    }
  var:
    {
      push(fp + 8);
    }
  varx:
    {
      push(fp + 8 + pop());
    }
  get_pc:
    {
      push(pc);
    }
  jump:
    {
      pc = pop();
    }

  // Branch if equal to zero
  beq(offset):
    {
      val = pop();

      if (val == 0)
      {
        pc = pc + offset;
      }
    }

  // Branch if not equal to zero
  bne(offset):
    {
      val = pop();

      if (val != 0)
      {
        pc = pc + offset;
      }
    }

  // Branch if equal to zero (signed 16-bit offset)
  beq_near(offset)
    {
      val = pop();

      if (val == 0)
      {
        pc = pc + sign_extend_16(offset);
      }

    }
  // Branch if not equal to zero (signed 16-bit range)
  bne_near(offset)
    {
      val = pop();

      if (val != 0)
      {
        pc = pc + sign_extend_16(offset);
      }

    }

  call:
    {
      // Address of function
      address = pop();

      // new arg_space
      n_arg_space = pop();

      // Stuff necessary for performing a function call
      call_sequence(address, n_arg_space);
    }

  ret:
    {
      return_val = pop();
      return_sequence(return_val);
    }


  // Load from memory or store to memory
  // 
  // Valid <type>'s are as follows:
  // basic (64-bit load/store)
  // u32 (unsigned 32-bit load/store)
  // s32 (signed 32-bit load/store)
  // u16 (unsigned 16-bit load/store)
  // s16 (signed 16-bit load/store)
  // u8 (unsigned 8-bit load/store)
  // s8 (signed 8-bit load/store)
  ld_<type>:
    {
      base = pop();
      push((s64)*((type*)(&mem[base])));
    }
  ldx_<type>:
    {
      base = pop();
      index = pop();
      push((s64)*((type*)(&mem[base + index])));
    }
  st_<type>:
    {
      base = pop();
      data = pop();
      *((type*)(&mem[base])) = data;
    }
  stx_<type>:
    {
      base = pop();
      index = pop();
      data = pop();
      *((type*)(&mem[base + index])) = data;
    }

  add:
    {
      a = pop();
      b = pop();

      push(a + b);
    }
  sub:
    {
      a = pop();
      b = pop();

      push(a - b);
    }
  mul:
    {
      a = pop();
      b = pop();

      push(a * b);
    }
  udiv:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a / b);
    }
  sdiv:
    {
      a = pop();
      b = pop();

      push(a / b);
    }
  umod:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a % b);
    }
  smod:
    {
      a = pop();
      b = pop();

      push(a % b);
    }


  bit_and:
    {
      a = pop();
      b = pop();

      push(a & b);
    }
  bit_or:
    {
      a = pop();
      b = pop();

      push(a | b);
    }
  bit_xor:
    {
      a = pop();
      b = pop();

      push(a ^ b);
    }
  bit_lsl:
    {
      a = pop();
      b = pop();

      push(a << b);
    }
  bit_lsr:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a >> b);
    }
  bit_asr:
    {
      a = pop();
      b = pop();

      push(a >> b);
    }


  cmp_eq:
    {
      a = pop();
      b = pop();

      push(a == b);
    }
  cmp_ne:
    {
      a = pop();
      b = pop();

      push(a != b);
    }
  cmp_ult:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a < b);
    }
  cmp_slt:
    {
      a = pop();
      b = pop();

      push(a < b);
    }
  cmp_ugt:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a > b);
    }
  cmp_sgt:
    {
      a = pop();
      b = pop();

      push(a > b);
    }
  cmp_ule:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a <= b);
    }
  cmp_sle:
    {
      a = pop();
      b = pop();

      push(a <= b);
    }
  cmp_uge:
    {
      const u64 a = pop();
      const u64 b = pop();

      push(a >= b);
    }
  cmp_sge:
    {
      a = pop();
      b = pop();

      push(a >= b);
    }


  // Display 64-bit integer
  disp_num:
    {
      cout << pop();
    }
  disp_num_unsigned:
    {
      cout << (uint64_t)pop();
    }

  // Display character
  disp_char:
    {
      cout << (char)pop();
    }

  // Display string
  disp_str:
    {
      cout << ((const char*)(&mem[pop()]));
    }

  // Get 64-bit integer from standard input
  get_num:
    {
      cin >> a;
      push(a);
    }

  quit:
    {
      exit(pop());
    }

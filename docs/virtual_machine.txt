For simplicity, this is a stack machine.
It uses byte addressing.
The basic integer type is implemented as int64_t.
Other types of integers are supported for loads and stores.


Registers:
  pc:   program counter
  sp:   stack pointer
  fp:   frame pointer (points to the start of the stack frame)
  arg_space:  size of space allocated for arguments


Stack frame:
  fp - arg_space - 24:  old fp
  fp - arg_space - 16:  old arg_space
  fp - arg_space - 8:   return value
  fp - arg_space:       arguments to this specific call of the function
  fp:                   return address
  fp + 8:               local variables of this specific call of the
                        function

Encodings:
  No arguments:         Two bytes used, representing
  constant(immediate):  

Instructions:
  // Put constant value onto the stack
  constant(immediate):
    {
      push(immediate);
    }

  arg:
    {
      push(fp - arg_space);
    }
  argx:
    {
      push(fp - arg_space + pop());
    }
  var:
    {
      push(fp + 8);
    }
  varx:
    {
      push(fp + 8 + pop());
    }
  get_pc:
    {
      push(pc);
    }
  jump:
    {
      pc = pop();
    }

  // Branch if equal to zero
  beq:
    {
      val = pop();
      offset = pop();

      if (val == 0)
      {
        pc = pc + offset;
      }
    }

  // Branch if not equal to zero
  bne:
    {
      val = pop();
      offset = pop();

      if (val != 0)
      {
        pc = pc + offset;
      }
    }

  call:
    {
      //call(pop());
      call_sequence();
    }

  ret:
    {
      //return(pop());
      return_sequence();
    }


  ld(type):
    {
      base = pop();
      push((s64)*((type*)(&mem[base])));
    }
  ldx(type):
    {
      base = pop();
      index = pop();
      push((s64)*((type*)(&mem[base + index])));
    }
  st(type):
    {
      base = pop();
      data = pop();
      *((type*)(&mem[base])) = data;
    }
  stx(type):
    {
      base = pop();
      index = pop();
      data = pop();
      *((type*)(&mem[base + index])) = data;
    }

  // Binary operator, such as math, logic, bitwise, and comparisons.
  // 
  // Note:  there are both signed and unsigned comparisons
  binop(type):
    {
      a = pop();
      b = pop();

      switch (type)
      {
        case ...:
          push(a op b);
          break;
          ...
      }
    }


  // Display 64-bit integer
  disp_num:
    {
      cout << pop();
    }
  disp_num_unsigned:
    {
      cout << (uint64_t)pop();
    }

  // Display character
  disp_char:
    {
      cout << (char)pop();
    }

  // Display string
  disp_str:
    {
      cout << ((const char*)(&mem[pop()]));
    }

  // Get 64-bit integer from standard input
  get_num:
    {
      cin >> a;
      push(a);
    }
